{"./":{"url":"./","title":"关于 svrx","keywords":"","body":"svrx svrx(server-x) 是一个渐进且易于使用的、插件化的前端开发工作台。 作为前端开发，在不同的开发需求下，一般来说我们会有一套或者多套固定的开发环境。 它可能包括本地服务器以及各种用于调试工程的小工具。 维护这样的开发环境是很麻烦的：你不仅需要单独安装每一个工具，还需要对每一个工具进行设置。 此外，针对不同的工程，你还需要有选择地去开启或关闭某个功能。 svrx 做的，就是利用插件机制来整合各种前端开发服务， 让前端开发者可以自由挑选所需的功能，如静态伺服、代理、远程调试等，且无需关心这些功能插件的安装过程。 有了svrx这样一个前端开发工作台，我们可以轻松做到一份配置对应一套开发环境，实现真正的一键启动开发服务。 特性预览 静态伺服 代理 自动重载页面 支持 Hot Reloading 的路由功能 更多的可能： 插件化 安装和使用 你可以在这里阅读使用指南。 官方插件 Debug svrx-plugin-weinre: 基于 weinre，在电脑上远程调试手机页面 svrx-plugin-eruda: 基于 eruda，直接在手机上开启 dev tool 进行调试 Mock svrx-plugin-json-server: 基于json-server,快速实现 REST API svrx-plugin-mock: 基于mock.js来便捷的实现数据 mock Build & Compile svrx-plugin-webpack: 提供 webpack 相关功能，编译、hot-reload 等 Serve svrx-plugin-markdown: 展示 markdown 类型的文件，提供实时预览、hot-reload、自动滚动定位等功能 svrx-plugin-json-viewer: 切换 JSON 响应为更友好的展示界面，并且它只影响到直接用页面访问的情况，不影响 fetch 或 xhr 的请求。 Network svrx-plugin-localtunnel: 暴露你的本地服务为公开的外网域名 Utility svrx-plugin-qrcode: 在页面上或 console 中展示当前页面的二维码 More 来插件集合 看看是否有你感兴趣的插件吧! 阅读下插件开发手册吧，发布属于你的插件其实一点都不难。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"quick-start.html":{"url":"quick-start.html","title":"快速上手","keywords":"","body":"快速上手 开始使用 svrx 吧！ 安装 svrx 我们推荐使用 cli 工具来管理和使用 svrx， 全局安装 cli 后你将可以在系统的任意地方使用 svrx。 npm install -g @svrx/cli 注意： cli 的作用是安装和加载你指定的svrx版本，这与 cli 本身的版本无关。 @svrx/cli 将安装的 svrx 包存储在 ~/.svrx， 你可以通过设置 SVRX_DIR 环境变量来改变这个存储路径。 用 svrx 启动你的工程 常用指令 @svrx/cli 提供了以下几个常用指令： svrx # 启动svrx服务 svrx serve # 同svrx（serve命令可省略） svrx --version # 查看 cli 及当前使用的 svrx 版本 svrx --help # 命令及参数提示 在工程中使用 svrx 启动服务 开始前，首先你需要进入到你的工程目录，我们假设你的工程中已经有一个 index.html： cd your_project ls # index.html 无需经过任何配置和传参，直接运行serve命令即可开启一个简单的本地服务器： svrx 此时访问 http://localhost:8000 ，就可以看到 index.html 中的内容了。 使用参数 如果需要对 svrx 进行配置，可以通过命令行传参来实现： svrx --port 3000 --https --no-livereload 详细的参数列表可以在这里查看。 配置持久化 当然，你也可以在你的工程目录下建立 .svrxrc.js 或 svrx.config.js 配置文件，将上面的命令行参数持久化下来： // .svrxrc.js module.exports = { port: 3000, https: true, livereload: false }; 然后直接运行 serve 命令， svrx 会自动读取你的配置文件。 全局配置 有些时候，你可能会有要全局配置某个参数的需要。 比如，我们假设，你的全部工程都需要默认使用 https 协议。 在每个工程中单独设置 https 为 true 太麻烦了， 这个时候你可以把全局配置文件放到开头提到的 svrx 包存储目录中，默认是 ~/.svrx/config： // ~/.svrx/config/.svrxrc.js module.exports = { https: true, }; 是的，全局配置文件和工程目录中的配置文件结构是一模一样的。 下一次，不管你在哪个工程启动 svrx，都会默认启用 https 协议。 不过，全局配置的优先级是最低的，你可以随时在工程中通过命令行参数或者配置文件对全局配置进行覆盖。 其它指令 另外，如果你需要关心 svrx 的版本安装情况，或是想安装某个特定的 svrx 版本，那么你还可以使用下面这些指令： svrx ls # 查看所有本地已安装的svrx版本 svrx ls-remote # 查看所有已发布的svrx版本 svrx install # 安装某个的svrx svrx remove # 从本地移除某个的svrx svrx remove # 从本地移除某个插件包的缓存文件 可以使用 svrx -h 查看指令详情及提示信息 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"plugin/":{"url":"plugin/","title":"插件体系","keywords":"","body":"插件体系 插件的使用 插件列表 如何写一个插件 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"plugin/usage.html":{"url":"plugin/usage.html","title":"插件的使用","keywords":"","body":"插件的使用 通过命令行 你可以通过命令行的方式去使用插件，例如： svrx --plugin markdown -p qrcode # -p 是 --plugin 的缩写 svrx --markdown --qrcode # 在命令行中设置某个插件名为 true 也可以快速开启一个插件 svrx --plugin \"qrcode?ui=false\" # 可以用 name?querystring 进行插件传参 svrx --plugin \"webpack@0.0.3\" # name@version 可以声明插件版本 通过.svrxrc.js配置 同样的，你也可以通过配置 .svrxrc.js 中的 plugins 字段来启用或配置插件，如： // .svrxrc.js module.exports = { plugins: [ 'markdown', { name: 'qrcode', options: { ui: false, }, }, { name: 'webpack', version: '0.0.3', }, ], }; 然后在项目根目录执行svrx命令， svrx会自动帮你安装markdown，qrcode和webpack插件，并运行它们。 scope svrx 插件支持 npm-scope。 在使用这样的 scope 插件时，你可以通过 @/ 的格式来声明这个插件。 比如有一个插件包名为 svrx-plugin-foo，且它的 scope 为 bar，那么你可以通过下面的方式使用它： svrx --@bar/foo svrx -p @bar/foo svrx -p \"@bar/foo@0.0.3\" 或者： // .svrxrc.js module.exports = { plugins: [ '@bar/foo', { name: '@bar/foo', options: { bar: false, }, }, ], }; 你可以使用官方脚手架 svrx-create-plugin 一键创建带有 scope 的插件。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"plugin/contribution.html":{"url":"plugin/contribution.html","title":"如何写一个插件","keywords":"","body":"如何写一个插件 使用svrx-create-plugin帮助你更容易的开发插件 第一个 svrx 插件 让我们实现第一个插件 —— svrx-plugin-hello-world， 它用来在终端和浏览器端分别打印用户欢迎语 文件结构 └── svrx-plugin-hello-world ├── client.js ├── index.js └── package.json 其实只有package.json 和 index.js是必须的 以下分别做下介绍 package.json { \"name\" : \"svrx-plugin-hello-world\", \"engines\": { \"svrx\" : \"0.0.x\" } ...略.. } 在package.json中只有 2 个字段是 svrx 依赖的 name: 包名要求必须是 svrx-plugin 开头，这是为了方便使用 npm 服务来进行插件查找 engines.svrx: 定义此插件的可运行 svrx 版本，svrx 会自动加载最新的匹配插件， engines.svrx 可以是一个 semver，如0.1.x或~0.1等 - index.js module.exports = { configSchema: { user: { type: 'string', default: 'svrx', description: 'username for hello world' } }, assets: { script: ['./client.js'] }, hooks: { async onCreate({ logger, config }) { logger.log(`Hello ${config.get('user')} from server`); } } }; 其中 configSchema 插件参数定义，请参考参数定义了解更多,这里我们定义了一个默认为'svrx'的字符串类型的参数 user assets: 前端资源配置，他们会被自动注入到前端脚本中 style: css 脚本注入，默认注入 html 头部，本例没有使用 script: script 脚本注入，默认注入 html 尾部 注入前端资源都会被合并成一个资源 hook.onCreate: 插件创建的钩子，在这里我们可以通过注入的服务组件来扩展插件，这里仅介绍使用到的服务 logger: 日志服务 config: 获取用户参数的组件 本例做的是在终端打印关于 user 参数的欢迎语 hook.onCreate 实际上还接受多种组件服务，具体请参考插件服务组件 - client.js 前端注入脚本中有一个「全局变量 svrx」， 挂载了一些 svrx 在前端的内置服务。 这个全局 svrx 仅在插件脚本内部可以访问，不用担心全局污染 const { config } = svrx; config.get('user').then(user => { console.log(`Hello ${user} from browser`); }); 这里我们仅仅是做了一个用户相关控制台 log 输出 与服务端的 config 组件不一样，这里的 config 是通过 websocket 传递的，所以接口返回的是 promise svrx 其实还暴露了其它前端服务，具体请参考前端 API '发布' && 运行 在根目录，我们直接运行npm publish .尝试发布，会发现发布失败了，因为hello-world插件已经被官方发布了。 所以我们跳过这一步，直接运行 svrx -p hello-world 检查下浏览器端和命令行终端将可以看到 'Hello svrx from browser' 的类似日志，说明插件已经生效 也可以通过脚本的方式来启动 const svrx = require('@svrx/svrx'); svrx({ plugins: ['hello-world'] }).start(); 进一步阅读: 如何本地测试? 插件服务 API 所有插件服务都可以在两个地方被注入 插件定义中的hooks.onCreate钩子 module.exports = { hooks: { async onCreate({ middleware, injector, events, router, config, logger, io }) { // use component here } } }; svrx 实例的plugin事件回调，此事件会在所有插件组装完毕后执行 svrx().on('plugin', async ({ logger, io }) => { // use component here }); 接下来，我们依次说明这 7 个组件 middleware middleware 负责添加满足 koa 风格的中间件 完成后端逻辑的注入 - middleware.add(name, definition) 增加一个中间件 Usage middleware.add('hello-world-middleware', { priority: 100, async onRoute(ctx, next) {} }); Param name [String]: 定义一个唯一的中间件名 debug 模式下根据此命名可以 track 请求响应的管线 definition.priority [Number]: 默认为 10. svrx 会根据 priority 由高到低的组装中间件，即请求会先经过高优先级的插件 definition.onRoute [Function]: 满足 koa 规范的中间件定义，如果 definition 是一个函数，则会自动成为 definition.onRoute - middleware.del(name) 删除一个中间件 Usage middleware.del('hello-world-middleware'); Param name: 传入add的名称 injector injector用来改写响应流或注入前端资源 - injector.add(type, definition) 增加一种注入资源, 目前支持原生的 js 和 css 注入，他们注入规则如下 样式会合并到/svrx/svrx-client.css下，并注入到 html 的head闭合标签前 脚本会合并到/svrx/svrx-client.js，并注入到 html 的body闭合标签前 Usage injector.add('script', { content: ` console.log('hello world') ` }); 上例会往/svrx/svrx-client.js 注入 content 字段中的脚本内容 Param type: 目前仅支持script以及style definition.content [String]: 资源的内容 definition.filename [String]: 资源文件，必须是绝对地址 content 的优先级高于 filename，二者取其一即可 - injector.replace(pattern, replacement) 自定义 html 的替换规则 Usage injector.replace(/svrx/g, 'server-x'); 上例将 html 中的 svrx 替换为 server-x Param pattern [String|RegExp] replacement [String|Function] injector.replace的使用与String.prototype.replace完全一致 资源注入就是通过injector.replace实现的 events 内置事件监听器，支持 async sorted emitter，即可以依次调用监听函数，并可在任意一个事件监听中终止事件传递 - events.on(type, fn) Usage events.on('hello', async payload => {}); events.on('hello', async (payload, ctrl) => { ctrl.stop(); // stop events emit, only works in sorted emit mode }); Param type [String]: 事件名 fn(payload, ctrl): 事件回调，它包含 2 个入参 payload [String]: 事件参数, 通过 emit 传入 ctrl [Object]: 控制器, 调用ctrl.stop()可终止 sorted emit 如果回调返回一个Promise(比如 async function)，视为一个异步回调 - events.emit(type, param, sorted) Usage // sorted emit, handler will be called one by one events.emit('hello', { param1: 'world' }, true).then(() => { console.log('emit is done'); }); // parallel emit events.emit('hello', { param1: 'world' }).then(() => { console.log('emit is done'); }); Param type [String]: 事件名 payload: 事件参数，被on中注册的回调函数接收 sorted [Boolean]: 默认false, 是否串行阻塞的触发事件 Return Promise - events.off(name, handler) Usage events.off('hello'); // remove all hello's handler events.off('hello', handler); // remove specific handler 内置事件 plugin: 当插件准备完毕后触发 file:change: 当文件发生变更时被触发 ready: 当服务启动时触发，如果你需要在服务启动处理部分逻辑(如获取服务端口)，请注册这个事件 config 插件配置管理 - config.get(path) 获取一个插件配置 config 内部维护的数据结构为不变数据，对于配置有实时性要求的，必须使用 config.get 来取值，确保获得最新配置项目 Usage config.get('user'); // get the user param of plugin config.get('user.name'); // get the user.name param of plugin 你也可以获取全局参数，只需要加$.前缀 config.get('$.port'); // get the server's port config.get('$.root'); // get the svrx working directory Param field: 配置名，深层配置用.分割，比如user.name Return 配置值 - config.set(field, value) 设置配置项 Usage config.set('a.b.c', 'hello'); // deep set config.get('a'); // => { b: { c: 'hello' } } Param field: 配置名，深层配置用.分割，比如user.name value 配置值 - config.watch([field, ]handler) 监听配置变化, 配置变化检查会在set、del、splice方法后被触发 config.watch( (evt)=>{ console.log(evt.affect('a.b.c')) => true console.log(evt.affect('a')) // => true console.log(evt.affect('a.c')) // => false }) config.set('a.b.c', 'hello'); Param field: 字段名, field是可选的，如不传入则所有 config 变更都会触发 handler(evt): 监听回调 evt.affect [Function]: 判断本次变更是否影响某字段 - config.del(field) 删除某个配置项 Usage config.del('a.b.c'); config.get('a.b.c'); //=> undefined Param 配置名 - config.splice(field, start[, delCount[, items...]) 数组 splice 的 config 版本 除了field外，其他参数与 Array.prototype.splice 一致 router 从插件层面扩展或注册Routing 模块 - router.route(register) 快捷注册路由，与Routing DSL一致 Usage const {route} = router; route(({all, get, post})=>{ all('/blog').to.send('Hi, Blog') get('/user').to.send('Hi, user') post('/user').to.send({code: 200, data: 'Success!'}) }) Param register({...methods}): 注册回调 methods: 对应HTTP methods - router.action(name, builder) 注册一个与 proxy、json 类似的 action Usage const { action, route } = router; action('hello', user => ctx => { ctx.body = `hello ${user}`; }); route(({ all }) => { all('/blog').hello('svrx'); //=> response 'hello svrx' }); Param name [String]: action 名，即后续的调用方法名 builder(payload) payload: 即传入 action 方法的参数，如上栗的'svrx' Return: builder 返回标准的koa 中间件 - router.load(filename) 手动加载一个 route 文件，与启动参数 route 一致 加载的文件同样支持 hot reloading Usage await router.load('/path/to/route.md'); Param filename: 路由文件的绝对路径 Return Promise logger 日志模块，它的分级可以通过logger.level来控制(默认为warn) svrx({ logger: { level: 'error' } }); 或从 cli 端 svrx --logger.level error 上例将会输出warn以上的日志，如notify、error logger[level](msg) svrx 提供了多种级别的日志，分别是silent, notify, error , warn(默认日志分级), info, debug Usage logger.notify('notify'); // show `notify` logger.error('error'); // show `error` and `notify` logger.warn('warn'); // show `warn`、`error` and `notify` logger.notify 由于会非常常用，所以它有一个 alias logger.log io io 负责插件后端与前端的通信， 请结合 client 端的 io 查看 - io.on( type, handler ) 监听浏览器端发送消息(即通过浏览器端io.emit发送) io.on('hello', payload => { console.log(payload); // =>1 }); Param type: 事件名 handler(payload): 事件回调 payload: 事件参数 - io.emit(type, payload) 发送 io 事件到客户端 Usage server side io.emit('hello', 1); client side const { io } = svrx; io.on('hello', payload => { console.log(payload); //=>1 }); Param type: 事件名 payload: 事件参数 注意事件参数必须是可序列化的，因为要通过网络传输 - io.off(type[, handler]) 解除监听 Usage io.off('hello'); //=> remove all hello handlers io.off('hello', handler); //=> remove specific handler - io.register(name, handler) 注册一个 io 服务， 它可以在客户端或服务端以io.call的方式调用 Usage io.register('hello.world', async payload => { return `Hello ${payload}`; }); Param name [String]: 服务名，call 中会被使用 handler: 服务逻辑实现，异步请返回 Promise 或使用 async/await - io.call(name, payload) 调用注册的服务 Usage 上例如下调用会返回 'Hello svrx' io.call('hello.world', 'svrx').then(data => { console.log(data); // => Hello svrx }); Param name [String]: 服务名 payload [Any]: 服务入参 Return Promise 客户端 API 客户端 API 统一通过 svrx 全局变量暴露，如下例 const { io, events, config } = svrx; 以下依次说明 io 通信模块，负责与服务端通信 - io.on(type, handler) 监听服务端 io 事件 Usage server side io.emit('hello', 1); client side const { io } = svrx; io.on('hello', payload => { console.log(payload); //=>1 }); 注意后端 io.emit 属于广播，所有前端页面都会收到信息 Param type: 事件名 handler(payload): 事件回调 payload: 事件参数 - io.emit(type, payload) 发送 io 事件到服务端 Usage client side const { io } = svrx; io.emit('hello', 1); server side { hooks: { async onCreate({io}){ io.on('hello', payload=>{ console.log(payload) // =>1 }) } } } Param type: 事件名 payload: 事件参数 注意事件参数必须是可序列化的，因为要通过网络传输 - io.off(type[, handler]) 解除监听 Usage io.off('hello'); //=> remove all hello handlers io.off('hello', handler); //=> remove specific handler - io.call(name, payload) 在 client 端的 io.call 与服务端完全一致，但要确保 payload 是可序列化的,因为会经过网络传输 Usage io.call('hello.world', 'svrx').then(data => { console.log(data); }); Param name [String]: 服务名 payload [Any]: 服务入参 Return Promise events 浏览器端内部的事件发射器，这部分和服务端 events完全一致，不做赘述 Usage const { events } = svrx; events.on('type', handler); events.emit('type', 1); events.off('type'); events 与 io 的不同在于 io 是 服务端与客户端的通信，而 events 是单端的事件触发器 config 客户端的config模块与服务端几乎一致，唯一区别是从同步接口变成了 Promise 化的异步接口(因为 socket 的网络通信) - config.get(field) Usage config.get('$.port').then(port => { // get the server port }); config.get('user').then(user => { //get the param belongs to current plugin }); 注意获取的参数是属于脚本的，如果获取全局请加$.前缀 - config.set、config.splice、config.del 上述三个方法和get一样，与服务端表现一致，不过返回值变为 Promise Usage config.set('a.b', 1).then(() => { config.get('a.b').then(ab => { console.log(ab); // => 1 }); }); 参数定义 svrx 支持一种基于 json-schema 扩展的参数定义，以内部定义的参数为例 Usage module.exports = { root: { type: 'string', default: process.cwd(), description: 'where to start svrx', ui: false }, route: { description: 'the path of routing config file', anyOf: [{ type: 'string' }, { type: 'array' }] }, logger: { description: 'global logger setting', type: 'object', properties: { level: { type: 'string', default: 'error', description: \"set log level, predefined values: 'silent','notify','error','warn', 'debug'\" } } } }; Field 详解 type [String]: JSON-Schema 允许的字段类型 ，可以是array、string、number、boolean、object、null default [Any]: 默认值 required [Boolean]: 是否是必须的, 默认是false properties [Object]: 定义属性，每层属性又是一层 schema 定义 ui: svrx 的扩展字段，是否要在 svrx-ui 中被展示 anyOf: 属性任选其一，如route: { description: 'the path of routing config file', anyOf: [{ type: 'string' }, { type: 'array' }], }, 进一步的 JSON Schema 定义请参考官方文档 如何测试? 不建议大家发布测试插件到 npm, 可以通过以下方式来进行本地测试 svrx({ plugins: [ { name: 'hello-world', path: '/path/to/svrx-plugin-hello-world' } ] }).start(); 指定 path 参数后，svrx 会加载本地包，而不是从 npm 中获取 更容易的插件开发 —— svrx-create-plugin svrx 官方提供的脚手架帮助你更容易的开发和发布你的插件 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"practice/":{"url":"practice/","title":"项目实战","keywords":"","body":"项目实战 特定场景使用 结合主流脚手架使用 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"practice/recipe.html":{"url":"practice/recipe.html","title":"特定场景使用","keywords":"","body":"特定场景使用 由于svrx提供了丰富灵活的插件系统，我们几乎可以在所有开发场景中使用svrx。 这里我们整理了一些svrx及常见插件的使用场景，希望这些配置能对你有帮助。 在静态页面启用服务器 代理 webpack 在移动端开启 eruda dev tool 利用 weinre 进行远程调试 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"practice/integration.html":{"url":"practice/integration.html","title":"结合主流脚手架使用","keywords":"","body":"结合主流脚手架使用 使用 create-react-app 或 vue-cli 初始化项目： # CRA npm init react-app my-app # Vue CLI npm i @vue/cli -g vue create my-app 项目根目录创建文件 webpack.config.js： // CRA module.exports = require('react-scripts/config/webpack.config')('development'); // Vue CLI module.exports = require('@vue/cli-service/webpack.config'); 好了，就这些 &#x1F389; svrx --webpack 结合 插件 使用更香哦 (ˇˍˇ) Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/":{"url":"guide/","title":"进阶指南","keywords":"","body":"进阶指南 Routing 路由的使用 API 列表 Option 列表 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/route.html":{"url":"guide/route.html","title":"Routing 路由的使用","keywords":"","body":"Routing 路由的使用 快速起步 你可通过以下命令来快速尝试 svrx 的动态路由功能 touch route.js # create empty routing file svrx --route route.js 在 route.js 中 get('/blog').to.json({ title: 'svrx' }); 打开 /blog，你将看到 {title: 'svrx'} 的 json 输出 特性 支持 hot reloading ( 通过编辑 route.js 来验证 ) 简单的书写，直观的阅读 支持通过插件来扩展和分发 语法 [method](selector).to.[action](payload) 举个例子 post('/blog').to.proxy('http://music.163.com'); 分别对应 method: post selector: /blog action: proxy payload: 'http://music.163.com' 其中 to 只是一个介词，可以省略 路由 路由方法 svrx 路由支持 methods 定义的 http methods ⚠️ 由于 delete 与 js 保留字冲突，你可以使用 del() 来创建 DELETE 方法 路由匹配 svrx 路由基于 path-to-regexp 匹配, 和两大平民 Node 框架 express 和 koa 相同. 查看 path-to-regexp 来了解更详尽的匹配规则，以下做简要概述 规则解析举例 /svrx/:id: 具名匹配，规则默认为 (\\w+) /svrx/:id(hello|world): 具名且指定匹配规则 /svrx(.*): 不具名匹配 /\\/svrx\\/(.*)$/: 对于复杂规则的路由，也可以直接使用正则表达式 匹配参数 具名匹配如/:id, 可以通过 ctx.params.id 获得 匿名匹配如/(hello|world)/(.*).html，可以通过 ctx.params[0] 以及 ctx.params[1] 依次获得匹配参数 正则匹配如/\\/svrx\\/(.*)$/，ctx.params[i] 依次获得正则的子匹配结果 参数快捷映射 除 Action:handle 外，大部分 action 在语法上不具备操作 koa 上下文( context ) 的能力，部分 action 做了 参数快捷映射 的支持 以 sendFile 为例 get('/html/:path.(html|htm)').to.sendFile('./{path}.{0}') /html/index.html 会发送 ${root}/html/index.html /html/home.htm 会发送 ${root}/html/home.htm Action 清单 你可以使用路由的 插件接口 来扩展 Action send 发送响应内容 get('/blog').to.send({ title: 'this is a blog' }); send 是 koa 框架 ctx.body 的语法糖，当 payload 类型不同时有以下默认行为 string 如果包含以开头的字符比如, Content-Type 头会设置为 text/html, 浏览器会渲染为 html 否则返回text/plain object or array or number or boolean ... 返回 json, Content-Type 为 application/json sendFile 发送文件内容，根据自动文件后缀设置 Content-Type get('/index.html').to.sendFile('./index.html'); 根路径 = serve.base || root ⚠️支持参数映射, 如下例 get('/file/:id.html').to.sendFile('./assets/{id}.html') json 无论 payload 为什么类型，都发送 json 响应 get('/blog').to.json({title: 'svrx'}); redirect(target[, code]) 服务端跳转 target: 目标 path code: http code, default 302 get('/blog').to.redirect('/user'); ⚠️支持参数映射, 如下例 get('/blog/:path(.*)').to.redirect('/user/{path}') header 设置响应头，由于 header 并不发送响应内容，你可以串联其他 action get('/blog') .to.header({ 'X-Engine': 'svrx' }) .json({ code: 200 }); rewrite 路由重写 ⚠️支持参数映射 get('/old/:path(.*)').to.rewrite('/svrx/{path}') get('/svrx(.*)').to.send('Hello svrx') 则/old/1和/svrx/1 都会返回Hello svrx 由于 rewrite 并不发送响应内容，你也可以串联其他 action proxy(target[, options]) 代理，将 path 代理到 target 服务器。 target: 目标服务器 options: 同 proxy.options changeOrigin secure pathRewrite get('/api(.*)').to.proxy('http://mock.server.com/') get('/test(.*)').to.proxy('http://mock.server.com/', { secure: false, }) get('/test/:id').to.proxy('http://{id}.dynamic.server.com/') handle handle 即定义一个 koa 的中间件，属于全能力 action，以上所有功能都可以使用 handle 来实现， 代价就是可读性的降低. get('/hello-world').to.handle((ctx)=>{ ctx.type = 'html' ctx.body = 'Hello World' }); 此外，handle 也可以接收一个 require 引入的 koa 中间件，比如： const bodyParser = require('koa-bodyparser'); post('/test/post').to.handle(bodyParser()).handle((ctx) => { ctx.type = 'html'; ctx.body = ctx.request.body; }); 尽可能抽取通用能力为自定义 action，请参考「插件接口」小节 插件接口 插件的 hooks.onCreate 会注入名为 router 对象, 包含三个方法 action: 注册一个与 proxy、json 等同级的 action load: 加载一个 routing file route: 脚本式的定义 router 详细请参考 插件开发指南 完整范例文件 get('/handle(.*)').to.handle((ctx) => { ctx.body = 'handle'; }); get('/blog(.*)').to.json({ code: 200 }); get('/code(.*)').to.send('code', 201); get('/json(.*)').to.send({ json: true }); get('/text(.*)').to.send('haha'); get('/html(.*)').to.send('haha'); get('/rewrite:path(.*)').to.rewrite('/query{path}'); get('/redirect:path(.*)').to.redirect('localhost:9002/proxy{path}'); get('/api(.*)').to.proxy('http://mock.server.com/') get('/test(.*)').to.proxy('http://mock.server.com/', { secure: false, }) get('/test/:id').to.proxy('http://{id}.dynamic.server.com/') get('/query(.*)').to.handle((ctx) => { ctx.body = ctx.query; }); get('/header(.*)') .to.header({ 'X-From': 'svrx' }) .json({ user: 'svrx' }); get('/user').to.json({ user: 'svrx' }); get('/sendFile/:path(.*)').to.sendFile('./{path}'); Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/api.html":{"url":"guide/api.html","title":"API 列表","keywords":"","body":"API 索引 svrx(option) 获得 svrx 实例 Usage const svrx = require('@svrx/svrx'); const server = svrx({ port: 8002 }); Param option: 查看 option 索引 Return Svrx 实例 server.start() 启动 Svrx Usage server.start().then(port => { console.log(port); }); Return Promise server.close() Usage server.close().then(() => { console.log('Svrx has closed'); }); Param Return Promise server.reload() 主动刷新浏览器 Usage server.reload(); server.on 绑定事件 内置事件 1. ready 在服务启动时触发 server.on('ready', port => {}); 2. plugin 在 build 插件后触发，与插件开发的hook.onCreate钩子接受同样的参数，请参考插件开发指南 server.on('plugin', async ({io, events, config, router, injector, logger, middleware }=>{ // you logic here })) 3. file:change 在文件变化后触发(必须 livereload 为 true) server.off 解绑事件 server.on('file:change', handler); server.off('file:change', handler); server.emit server.emit('custom-event', { param1: 1 }); Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/option.html":{"url":"guide/option.html","title":"Option 列表","keywords":"","body":"参数列表 root string 启动 svrx 的路径, 默认是当前工作目录。 svrx string 你想使用的 svrx 核心包的版本。默认会使用本地安装的最新版 svrx，如果未安装过，则会安装并使用当前发布过的最新版。 port number 端口号，默认是 8000 https boolean 开启/关闭 https。默认是 false。 route string 指定 routing 配置文件 ，详细说明请点击 routing dsl 详细指南 svrx --route route.js 它支持 hot-reload ，即你可以在不重启 svrx 的情况下更新路由规则 livereload boolean, object 开启/关闭页面自动刷新功能， 默认是开启的。 livereload.exclude string, string[] 设置文件忽略规则，如果文件符合任意匹配的 pattern，那么该文件的内容变动不会触发页面刷新。 serve boolean, object 本地服务器配置 serve.base string 告诉服务器从哪里提供静态文件。 默认情况下，我们会先查找当前工作目录下的文件。 你只需要在你想伺服静态资源的时候设置这个选项。 serve.index string 访问根路径时自动展示的 index 文件的文件名，默认是index.html。 serve.directory boolean 开启/关闭serveIndex middleware， directory默认是开启的。 访问根路径时，如果你的 index 文件不存在，serveIndex middleware可以提供一个目录中文件列表的视图，而不是返回 404。 open boolean, string 是否在 svrx 启动后自动打开浏览器， 默认是自动打开本地地址http://localhost:${port}。 你也可以用open指定需要打开的页面： false: 禁用自动打开浏览器 true: 同 'local' 'local': 打开本地地址，如http://localhost:${port} 'external': 打开外部，http://10.242.111.80:${port}/ ( 根据你的内网 IP ) 'home.html': 同'local/home.html' 打开 http://localhost:${port}/home.html historyApiFallback boolean, object 开启/关闭historyApiFallback middleware，默认是关闭的。 如果你的 app 使用了HTML5 History API，那么你可能需要开启这个选项。 historyApiFallback middleware会在请求 404 后返回index.html页面。 proxy proxy 也支持在 route 文件中动态配置 boolean, object, object[] url 转发配置。 你可以在当前域名下设置proxy，将不同的 url 转发至不同的后端地址。 module.exports = { proxy: { '/api': { target: 'http://you.backend.server.com' } }, } 经过如上配置后，一个/api/path请求会被转发至http://you.backend.server.com/api/path。 你也可以重写路径，就像这样： module.exports = { proxy: { '/api': { target: 'http://you.backend.server.com', pathRewrite: {'^/api' : ''} } }, } 现在你的/api/path请求会被转发至http://you.backend.server.com/path。 如果 target 后端的 HTTPS 服务器的证书是无效的，那么请求默认不会被接收。 你可以配置secure来改变这个默认设置: module.exports = { proxy: { '/api': { target: 'https://you.https.server.com', secure: false } }, } 如果你想同时把多个 path 转发到一个相同的地址，可以试试这样做： module.exports = { proxy: [ { context: ['/api', '/wapi', '/pub'], target: 'http://you.backend.server.com', } ], } 如果你想改变 header 中的 origin 为目标域名，可以试试将changeOrigin设为true： module.exports = { proxy: { '/api': { target: 'https://you.https.server.com', changeOrigin: true } }, } cors boolean, object 开启/关闭跨域资源共享（CORS）支持。 默认 Cors 是开启的。 svrx 依赖koa2-cors做跨域资源工程支持，更多使用方法和参数请阅读koa2-cors 参数文档。 registry string npm源地址，设置此选项后，svrx将从此源下载插件。 默认的registry值是你工作目录下的源地址值，即npm config get registry的结果。 path string svrx 核心包的本地路径。仅用于开发模式下加载本地 svrx 核心包。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"contribution.html":{"url":"contribution.html","title":"贡献指南","keywords":"","body":"贡献指南 Show me your code! svrx 欢迎各种形式的贡献： 代码、issue、文档等等。 你有任何想法或建议，也请一定要告诉我们。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"blog/":{"url":"blog/","title":"Blog","keywords":"","body":"Blog 这里是 svrx 团队的博客页面， 我们会不定期更新一些关于 svrx 的介绍、使用、设计等文章。 欢迎大家一起交流讨论～ 关于我们 svrx 由网易云音乐前端技术团队精心打造。 除了 issue & pr 交流以外， 也欢迎加入 svrx 微信交流群（由于群人数限制，目前只能添加好友邀请入群）： Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"blog/introduction.html":{"url":"blog/introduction.html","title":"Server-X：一款可能提升你十倍工作效率的工具","keywords":"","body":"Server-X：一款可能提升你十倍工作效率的工具 本文将介绍一款全新的前端开发工具，希望它能给你的前端开发带来看起来和现在一样但其实又不那么一样的体验。 你可能会说，大家都是 秃头的 成熟的前端程序员了，每一台电脑上都有几套自己辛辛苦苦装好的全家桶，为什么还要新换一个开发工具？ 对，盲生，你可能发现了华点。 数一数你电脑上目前为前端本地开发安装了多少小工具、小插件？ 这其中仅仅是为代码开发阶段，就可能有本地服务器、远程调试工具、代理工具、浏览器插件等等。 它们也许是你一个个尝试无数同款后最终确定安装的， 也可能是被各类『震惊！超好用前端开发工具大全』安利的， 并且其中不乏全局安装、全局配置的「重器」。 试想现在你要换一台新电脑或者重装新系统了，你还得一个个把它们重新安装回来。 况且大部分这样的工具是无法根据工程进行独立配置的， 也就是说你在不同项目之间切换时还需要手动修改你的开发工具配置。 这些都是一些强迫症患者如作者本人无法忍受的。 总结一下平时搞开发的时候一些习以为常但仔细一想又挺麻烦的场景： 你必须手动安装各类工具软件以丰富你的本地开发环境 这样的本地开发环境无法拷贝或者很难拷贝，无法分享 每种工具都要单独配置，且配置基本不是按照项目隔离的，切换项目时经常需要修改配置 有时候你的需求并没有合适的工具来满足，自己写一个又太麻烦 写一个项目要同时打开 N 种 工具：本地服务器、mock 服务器等 经常还需要不断重启这些工具以刷新配置 …… 基于以上以及一些其它痛点，便有了下文将介绍的 server-x。 什么是 server-x 如同它名字的前半部分，server，你可以简单地说，server-x（缩写为 svrx）就是一个本地服务器， 并且它还是一个功能丰富、使用便捷的轻量级服务器。 先来看下最简单的使用场景： 首先你需要安装 svrx 的 CLI 工具， npm install -g @svrx/cli 然后新建一个简单的页面，在项目根目录启动 svrx， mkdir example && cd example echo 'Hello svrx!' > index.html svrx 访问 http://localhost:8000 即可看到你的前端页面。 安装便捷，启动迅速，独立使用，除了 node ，不依赖任何别的环境。 当然，这是任何一个独立的、基础的开发服务器都能做到的最必不可少的功能。 除此之外还有什么？svrx 还自带了诸如自动打开浏览器、监听代码变动自动刷新（livereload）、proxy 等实用性非常强的功能。 是的，你也可以说，部分开发服务器也是能做到的。 svrx 和其它本地服务器最大的区别，其实是它名字 server-x 的后半部分：x。 我们都知道，x 可以代表「未知和无限」，即 svrx 是一个有着无限可能的服务器。 为什么说它有无限的可能？因为 svrx 最大的特点：它是一个插件平台。 通过插件，理论上你的 svrx 确实可以拥有任意的功能。 每一个小功能在这里就是一个独立的插件，你只需要声明就能使用它，就像这样： svrx --webpack --qrcode --markdown 很清晰直观，没有冗余的配置，在你声明插件以后，svrx 会自动帮你下载安装插件，然后直接启动。 所以你可以说，svrx 是一个聚合了众多功能插件的平台，它本身就是一个全家桶。 不过不同的是，你丝毫不需要关心插件的安装过程。除了 svrx 的 CLI，你无需安装其它任何工具。 另外，所有插件都不是全局安装，而是直接安装到你工程的node_modules目录中。 所以工程开发是真正独立隔离的， 你可以自由给每一个项目定制一套开发环境，不用考虑安装卸载，完全不担心环境污染问题，同时系统也可以保持干净清爽。 事实上，业内目前可用的本地开发服务器有很多， 但像 svrx 这样，轻量易用的、具有完备插件机制的、完全不依赖工程环境的，几乎是没有的。 接下来，我们通过创建一个简单的前端工程，继续探索一下使用 svrx 进行开发的全新体验， 带你深入了解一些进阶用法和黑科技，这些才是 svrx 真正有趣的地方。 创建工程及启动 方便起见，我们选用前端常用的 Create React App 进行示例工程创建 （前面提到，svrx 不依赖任何工程环境，选取 CRA 仅仅为了示例方便）。 npm init react-app svrx-example cd svrx-example 由于新工程默认使用 webpack 打包，想要启动这样的工程， 我们需要使用插件 svrx-plugin-webpack。 这个插件的作用就是读取项目配置， 调用 webpack-dev-middleware， 使你的 webpack 项目可以无缝接入到 svrx 服务中。 不过由于新工程并没有暴露出 webpack 配置项，所以我们需要先在根目录创建一个 webpack.config.js： // webpack.config.js module.exports = require('react-scripts/config/webpack.config')('development'); 然后我们就可以顺利启动项目了： svrx --webpack 浏览器会自动弹出 http://localhost:8000/ 页面： 这时可以尝试编辑下 src/App.css，看看页面是不是实时变化了？ 进阶 1：添加配置项 默认地，svrx 会在启动时自动开启一些内置的基础插件， 如静态伺服（serve）、转发服务（proxy）、页面自动刷新（livereload）等。 它们都有一些默认行为以保证用户可以快速启动 svrx， 当然，如果你需要对这些内置配置项做一些自定义修改，svrx 也提供了两种方式。 你可以在命令行启动 svrx 时传入参数进行配置： svrx --port 3000 --https --no-livereload 也可以在你的工程目录下建立.svrxrc.js或svrx.config.js文件，将上面的命令行参数持久化下来： // .svrxrc.js module.exports = { port: 3000, https: true, livereload: false }; svrx 的全部配置项及描述可以在官方文档-内置项中查看。 进阶 2：开始尝试使用其它插件 除了内置插件以外，svrx 还有很多独立插件，比如前面提到的 svrx-plugin-webpack。 在你需要别的开发功能（如远程调试、mock 等）时，只需要简单地在 svrx 配置中声明这些独立功能插件的名字即可正常使用。 正是这些独立插件，为 svrx 项目提供了丰富多彩的功能体验。下面先介绍几个好用的好玩的插件： localtunnel - 把本地服务暴露出去 试想你正紧张有序地在进行页面开发，这个时候你领导的消息弹了出来： 让我看看你的页面写得怎么样了 这个时候你怎么办？你是不是得先检查进度，把能用的代码先提交，然后你灵机一动，部署了一个本地服务，准备甩给你领导一串本机 IP。 但是你突然想起来，领导不是在出差吗？（太敬业了，还在时刻检查你的开发进度）领导访问不了内网啊。 这时你只能慌忙找服务器再部署一个测试环境给领导，部署得还贼慢，领导飞机都要起飞了！ 这个时候，你就需要 svrx 的 localtunnel 插件了！ 它可以将你的本地服务暴露到localtunnel.me，从而方便地进行本地代码的测试和分享。 你再也无需为了测试你的一点代码变动就专门部署一次测试服务了。 启动 localtunnel 只需在之前的启动命令后添加声明即可： svrx --webpack --localtunnel 上面的命令将会自动安装 localtunnel 插件并启动 svrx， 其他人（是的，你们甚至不需要在同一个内网）此时访问终端打印的 https://*.localtunnel.me 也将看到你的本地服务： 并且，你的每次本地页面变动都可以被别人实时看到，再也不用担心领导突然检查作业了！ weinre - 远程调试移动端代码 现在一般都是如何进行移动端代码调试的？你可能会说，“这题我会！”很简单，先在手机上打开设置里的开发者模式（可能要找一下），允许USB 连接，再找一根 USB 连接线，把手机和电脑连接起来，然后你打开你电脑上的浏览器开发者工具，开启一些东西，找到远程设备，然后Inspect…… 万一有更简便的方法呢？你可以试试 svrx 的 weinre 插件，它用于方便地远程调试移动端的页面，而且是“无线”的。 我们再次回到刚才的 example 工程，这次我们在启动命令后面添加两个新的插件： svrx --open=external --webpack --weinre --qrcode 首先通过上面的命令快速安装 weinre 和二维码插件并启动 svrx， 此时试着拿手机访问启动好的项目页面，这里推荐配合 qrcode 二维码插件让手机轻松扫码访问页面地址: 紧接着电脑打开 weinre 的调试器页面 http://${your_ip}:8001（默认）， 找到手机的访问记录，就可以在调试器上对手机页面进行远程调试了。 定制你的插件 除了上述的，svrx 还有很多有趣好用的插件，你可以在svrx 的官网 查询目前所有的插件，并从中挑选使用。 通过不同插件的组合，你就可以自由定制你的开发环境啦！ 当然，如果没找到你想要的功能插件，你还可以尝试自己写一个。 你可以用插件实现哪些功能呢？ 拿前面的 qrcode 二维码插件来说，为了把二维码显示到页面上，你可以往前端页面注入一些 js 脚本，css 样式； 也可以像 webpack 插件那样，往后端逻辑中注入一些 koa 风格的中间件，拦截请求做数据处理，比如这里的 webpack-dev-middleware。 有了强大的前后端注入能力，几乎所有的本地开发需求，都可以通过创建一个 svrx 插件来解决。 而且插件的开发异常简单！刚刚介绍的一些插件的核心代码几乎都只有 50 行左右！ 此外，svrx 还提供了快速创建插件的脚手架工具，可以去官方文档-如何写一个插件查看更多插件开发的细节，在这里就不赘述了。 进阶 3：可以热更新的快捷路由 在前后端分离的开发场景中，前端经常会碰到需要进行数据 mock 的情况。于是你可能会经历： 修改 mock 数据，重启 mock 服务器 打开、关闭接口转发，重启 修改工程代码，重启 …… 就算你说现在的 mock 服务都很智能，不需要重启了，但是你还是需要在本地服务外手动再开启一个 mock 服务，要么就是狠一点，把 mock 数据写到工程代码里。太不优雅了！ 于是 svrx 的动态路由就派上用场了。是的，除了丰富的插件体系，svrx 其实还有一个功能强大、使用便捷的动态路由功能。 还是回到我们的 example 工程，你可以通过以下命令开启快速尝试： touch route.js # create empty routing file svrx --webpack --route route.js 在route.js中： get('/blog').to.json({ title: 'svrx' }); 此时打开/blog，你将看到{ title: 'svrx' }的 json 输出。 有了这个路由功能，你将可以在不侵入项目代码的前提下快速直观地创建你的 mock 数据。 并且它是支持 hot reload 的，即每次编辑 route.js 后，无需重启 svrx 服务，路由数据会自动更新。 当然，除了用于本地开发数据 mock 外，svrx 路由还可以做很多。下面是一些路由示例： get('/index.html').to.sendFile('./index.html'); get('/blog').to.redirect('/user'); get('/old/rewrite:path(.*)').to.rewrite('/svrx/{path}'); get('/api(.*)').to.proxy('http://mock.server.com/'); get('/blog') .to.header({ 'X-Engine': 'svrx' }) .json({ code: 200 }); 如你所见，svrx 的路由语法非常简单，你可以清晰直观地阅读出每一条规则，比如发送文件、重定向、路由重写、proxy 等等。并且除了官方提供的一些路由操作外，你也可以通过插件来对路由操作进行扩展。关于 svrx 路由的语法规则、扩展等详情可以参阅官方文档-路由的使用。 写在最后 一个渐进且易于使用的、插件化的前端开发平台。 这是 svrx 的 slogan，同时也非常准确地描述了 svrx 的定位： svrx 是面向前端开发者的一个强大的本地开发服务器，它由本地服务、proxy、livereload 等功能插件组成 svrx 有着丰富强大的插件系统，你可以自由使用或者定制想要的功能 在致力于为前端开发者提供更为优雅便捷的本地开发体验的同时，svrx 也为大家提供了一个可以快速进行自定义功能开发的平台。 作为用户，你可以挑选合适的插件组合来满足你的本地服务需求，一键启动，省时省力，易拔插的功能设计，也不用担心环境污染。 如果没有找到合适的插件，你可以变身开发者，自给自足，快速实现想要的功能。作为开发者，你还可以大开脑洞，通过你写的插件提升更多人的本地开发体验。 之后，svrx 也将继续推出更多优质功能或插件，持续为前端开发服务。 Links svrx 官网 官方使用文档、API、插件查询 Github - svrx 核心源码、讨论交流、bug report Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"blog/mock.html":{"url":"blog/mock.html","title":"使用 svrx 实现更优雅的接口 Mock","keywords":"","body":"使用 svrx 实现更优雅的接口 Mock 导言 目前 Web 开发普遍都切换到了前后端分离的开发模式。虽然在工程和职能上已经分离了，但在实际工作中，前后端在开发进度上往往会出现不一致的情况，此时就会极大地影响开发效率。 接口 mock 在此时就发挥出了巨大价值，它磨平了这个时间差，最终实现高效的前后端分离开发。 具体到接口 mock 方案就多种多样了，但大体不外乎 「硬编码」 、 「前端拦截」和「后端拦截」这三种。 本文会尝试简单分析这三种常见方案的优劣，然后引出主要议题：基于 svrx 的接口 mock 方案。 硬编码方案 硬编码即在前端代码中直接写入 mock 数据，比如： function getUser(id) { return { username: 'mock username', id: 100 }; //接口mock return ajax('/user', { id }); } 提交时移除或注释掉即可： function getUser(id) { // return {username: 'mock username', id: 100} return ajax(`/user/${id}`); } 后端硬编码的 mock 方式亦是如此，不过它的侵入性保留在了后端逻辑中，前端的业务代码可以保持干净： router.get('/user/:id', async ctx => { ctx.body = { username: 'mock username', id: 100 }; // ctx.body = await userService.get(ctx.params.id); }); 注：上述范例基于 Koa 框架 硬编码的优点 简单灵活，不需要任何工具和框架支持，就地使用。 如果是前端硬编码，支持修改生效，不需要重启 server。 硬编码缺点 接口 mock 和业务代码耦合，挖坑一时爽，填坑火葬场。 这种骚操作估计很多人年轻时都干过，提交时忘记删除导致夹带私货上线的车祸现场历历在目。 无论是否用一些专业的 mock 框架（比如 mock.js ），这种在业务逻辑中耦合的方式显然是下下策，线上事故通报中可能往往因此就有了你的名字。 稍严谨的同学可能会配合构建工具(如 webpack )来实现本地 mock 代码和业务代码的隔离，但并未在本质上解决这种耦合关系，随着项目的迭代，项目同样也会变得难以维护。 更好的做法其实是将 mock 逻辑与业务逻辑完全解耦，并放到独立的切面中管理， 这样就可以避免将非业务代码提交到仓库。 这种切面分为前端拦截和后端拦截两种方式，如下图所示，数据响应直接在对应的切面中被拦截返回： 前端拦截 前端拦截即在请求真正发送前做的拦截返回，这种切面通常可以通过 「Webview 容器定制」 和 「浏览器插件」 两种方式来实现。 Webview 容器定制 Webview 容器定制一般可以通过「网络拦截」和「脚本注入」两种方式，这也是一般混合应用中前端和 Native 交互的主要方式。 网络拦截 网络拦截经常会用在类似离线包的功能场景中，配合 mock 管理工具当然也可以用来接口模拟。 参考 Android，一般会使用下面的方法进行拦截来替换响应 public WebResourceResponse shouldInterceptRequest(final WebView view, final String urlstr) 此内容不是本文主要议题，不再深入展开 脚本注入 Android 和 iOS 都有能力向 Webview 直接注入 JS 逻辑，这也是 Hybrid 应用中 Bridge 通信层的实现方式。 如果在注入脚本中通过魔改 fetch 或 XMLHttpRequest 等原生对象，就可以达到对响应的拦截改写。 iOS 关键 API 举例 [self.webView stringByEvaluatingJavaScriptFromString:injectjs]; Android 关键代码片段 webView.loadUrl(\"javascript:\" + injectjs); 但无论是网络拦截还是脚本注入，基于 Webview 容器的拦截很少会用在真实场景中，因为定制和使用成本都太高，而且只在本 App 中可以被使用。 浏览器插件 相较于定制 Webview 容器，浏览器插件显然是一个成本更低的前端容器劫持方案。 以 code-mancers/interceptor 这个项目为例： 通过 Interceptor 插件，可以很容易以 GUI 的方式配置我们的 mock 数据，简单直观，且完全不侵入工程代码。 前端拦截分析 前端拦截有个两个天然优势： 可提供配置界面：由于是在浏览器端拦截，可使用 DOM API 提供例如Interceptor 插件的可配置界面。 就地生效：修改后无需重启服务。 但无论是浏览器插件还是定制 Webview 容器，实际上我们都忽略了一个重要事实：浏览器环境其实是多种多样的。 这导致了前端拦截的一个典型缺陷：无法跨浏览器使用，如上例的Intercepror 插件就无法在微信浏览器中使用。 如果是通过服务端拦截的话就可以避免这种情况。 服务端拦截方案 服务端拦截实现接口 mock，主要通过一个单独的 dev server 层来实现，它一般在访问真实接口前拦截请求并返回模拟数据。 裸奔的 dev server 方便起见，以 Koa 为例，裸奔一个 dev server： const proxy = require('koa-proxy'); const Koa = require('koa'); const app = new Koa(); app.use((ctx, next) => { switch (ctx.path) { case '/api/blog': ctx.body = { type: 'blog' }; break; case '/api/user': ctx.body = { type: 'user' }; break; default: return next(); } }); app.use( proxy({ host: 'http://api.yoursite.com' }) ); app.listen(8000, () => { console.log(`server start at http://localhost:8000`); }); 如上例所见, 默认会将接口代理到 api.yoursite.com(你的目标 API 或后端基友的服务器)。 mock 数据的优先级大于真实的代理接口，比如我们访问https://localhost:8000/api/user，返回的就是我们的 mock 数据，后续如果需要增加 mock 接口，则需要不断添加 case 分支。 这种裸奔的方式很不直观，因为它将 mock 规则和其他 dev server 的配置逻辑杂糅了，且对于非 Node 选手有较高的学习成本。 专业的 dev server 由于裸奔 server 的明显痛点，一些聚焦于 dev server 领域的解决方案就开始大行其道，比如开发者耳熟能详的 webpack-dev-server。 它集成了一些通用服务配置，例如端口、host、代理等等，并且设计为被集成在 webpack 的构建流程中以实现构建产物的 serve。 这样我们就可以将 mock 逻辑比较独立的嵌入其中，以下述 webpack 配置为例： module.exports = { //... devServer: { port: 9000, headers: { 'X-Custom-Foo': 'bar' }, proxy: { '/api': 'http://localhost:3000' }, before(app) { // 配置mock逻辑 app.get('/api/blog', function(req, res) { res.json({ custom: 'response' }); }); } } }; (专业的 dev server 用预设的配置代替了手工的代码逻辑，显著提高了开发效率) 但无论是裸起还是使用专业的 dev server，本质上还是存在以下问题： 不支持热重载: 每次修改 mock 规则，都需要重新启动服务器。 不直观: mock 规则和其他 server 配置杂糅，且对于非 Node 选手有较高的学习成本。 无法提供界面支持，相较于前端拦截, 它无法提供 GUI 的界面配置能力。 使用 svrx 实现高效的接口 mock 从以上分析可以得出：前端拦截与后端拦截，都存在一些本质缺陷。 那是否有一种方式是同时拥有前后端接口 mock 的优势呢？答案就是 svrx。 广告高能预警，看到这一步了，相信你已经是 svrx 的潜在客户了 svrx 简介 svrx(音：Server-X) 是一个微内核架构、插件化的前端开发服务器，内部功能模块主要包含三个部分： 前端注入模块： svrx 劫持所有 html 响应注入种子脚本，此脚本会集成管理所注册的前端资源（JS、CSS）。 后端注入模块： svrx 内置一个带有优先级的中间件注册模块。 前后端通信模块： 实现前端与后端注入的通信方式统一(基于 websocket)，可以以同构的方式完成事件或消息通信。 如上图所示，通过清晰的模块划分，插件可以以统一的方式来完成插件注册，灵活使用前端和后端注入功能。 svrx 也抽离了 dev-server 的通用功能，作为内置插件集成(包括 livereload、proxy、https 等等)，其他专有领域的功能(如 markdown、qrcode 等)则以外部插件的方式提供，最大化实现便捷和灵活的平衡。 其中细分到接口 mock 领域，目前也有一系列开箱即用的配套满足开发者的需求。让我们来试一试吧！ 安装 npm install @svrx/cli -g 注: 后续所有插件能力都不需要再显式安装了 使用 切换到你的工作目录并运行svrx，你会发现一个通用的 dev-server 已经运行起来了。 svrx svrx Routing DSL 实现接口 mock 具体到接口 mock 的需求，我们可以直接使用内置的动态路由功能： touch route.js svrx --route route.js 以上就是成功启动的界面, 在route.js加入以下代码： get('/api/user/:id').to.json({ name: 'svrx' }); 浏览器打开/api/user/1，可以看到对应的 JSON 响应。所有在route.js的改动都是支持 hot reload 的，我们无需重启服务器。 更多 svrx Routing DSL 的使用指南请点击这里 如果你使用 svrx 路由来代替上面的其他 dev-server，除了路由写法更直观高效外，还有一个作用就是可以更细粒度地管理路由的优先级，比如 mock 和 proxy 的优先级： get('/api/user/:id').to.json({ name: 'svrx' }); post('/api/blog(.*)').to.proxy('http://path.to.api.com'); get('/(.*)').to.send('404 PAGE IS NOT FOUND'); 注:路由规则越前置，优先级越高 使用 mock 插件来快速模拟接口 直接裸用 svrx 路由能解决 mock 的功能性问题，但无法解决 mock 的效率问题。 基于此，svrx 官方提供了svrx-plugin-mock， 它内置了好用的 mock.js ，帮助我们实现快速数据模拟： svrx --mock --route route.js 直接使用 -p mock 或简写--mock 来激活这个插件。 如上图红框所示，svrx 的插件体系有首次即安装的特性，被安装插件会自动进入 svrx 全局管理，后续激活插件无需重复下载，更重要的是不会污染你的工作目录(包括node_modules)。 在route.js中加入以下代码： get('/api/user/:id').to.mock({ name: '@name', email: '@email' }); mock 插件注册了一个名为 mock 的路由 Action，可在 Routing DSL 中被使用 再次访问/api/user/1，你会得到以下满足一定模式的随机响应，比如： { \"user\": \"Linda Thomas\", \"email\": \"g.ykyiexto@toaloso.cc\" } 除此之外，mock 插件也能快速模拟一些列表循环的逻辑, 比如： get('/api/user/:id').to.mock({ name: '@name', email: '@email', 'region|1-3': ['@region'] }); 对应的响应中region将会是一个长度是 1 到 3 的地区数组，比如： { \"name\": \"Nancy Allen\", \"email\": \"aopao@qpo.scm\", \"region\": [\"西北\", \"华中\"] } 可以看到使用 mock 插件可以大大提高我们的 mock 效率，并且阅读仍然很直观。 使用 json-server 创建基于一定规则的批量接口 svrx 的 mock 插件加上内置的动态路由功能基本上能高效的处理 90% 的本地 mock 需求了。 但如果你的服务是基于 json-server 规范的，你也可以利用 svrx-plugin-json-server 来快速实现海量接口，让我们一起来试下吧。 首先在当前目录创建如下内容的 db.json 文件： { \"posts\": [{ \"id\": 1, \"title\": \"json-server\", \"author\": \"typicode\" }], \"comments\": [{ \"id\": 1, \"body\": \"some comment\", \"postId\": 1 }] } 启动 svrx 并激活 json-server 插件： svrx -p json-server --route route.js 与 mock 类似，json-server 插件会注册一个名为 jsonServer 的路由 Action。 在route.js 加入以下配置： route('/(.*)').to.jsonServer(); 以上语句会将所有请求直接代理到内部的 json-server 模块。 访问 /posts, 将看到如下响应： [ { id: 1, title: 'json-server', author: 'typicode' } ]; 值得一提的是，其实 json-server 内置了全部 crud 操作，以posts为例： POST /posts => Create 即创建操作 UPDATE /posts/:id => UPDATE 即更新操作 GET /posts/:id => READ 即读操作 GET /posts => READ LIST 即列表读操作 DELETE /posts/:id => DELETE 即删除操作 举个栗子，当你发起一个创建请求(以前端 fetch 为例): fetch('/posts', { method: 'POST', body: JSON.stringify({ title: 'svrx', author: 'x-orpheus' }), headers: { 'content-type': 'application/json' } }); 你再访问 /posts 列表，会发现多了一条记录，且这条记录会同步持久化到db.json: [ { id: 1, title: 'json-server', author: 'typicode' }, { title: 'svrx', author: 'x-orpheus', id: 2 } ]; 请求改写 通过串连路由的 rewrite 指令，我们可以做到只引导部分流量到 json-server 服务，例如: route('/api/(.*)') .rewrite('/{0}') .to.jsonServer(); // /api/posts => /posts 这样只有/api开头的请求会代理到 json-server，其他请求可以走其他的 mock 逻辑。 使用接口管理平台 以上所有的 mock 方式其实都有一个较大的问题，就是 mock 规则都是在本地的，我们无法共享配置。 而实际上较大的团队都应该有 API 接口管理平台来统一管理接口定义，在网易我们使用NEI：接口管理平台来管理 API(由云音乐前端团队维护，欢迎免费试用)。 一般这类平台都有接口模拟功能，代理到这类平台，我们可以轻松实现规范化的接口 mock： 搭配这种接口管理平台，云音乐团队也封装了 svrx-plugin-nei (即将开源)来实现代理到 NEI 平台的数据模拟，如下图所示: 基于接口管理平台的接口模拟是与真实接口规范匹配的，所以前后端规范性会更一致，并且它的平台属性也方便开发者共享配置。 但这种方式也有巨大的劣势，就是灵活度远低于本地接口模拟。 值得一提的是此插件利用 svrx 的前端注入能力实现了跨浏览器的前端配置界面， svrx 通过内部 injector 模块自动为响应是 html 类型的资源注入种子脚本，种子脚本会集成所有 plugin 注册的脚本内容，从而实现了前端逻辑在 dev-server 侧的注入。 通过 mock 解析 svrx 的核心价值 我们可以看到，以上所有特性在数据 Mock 领域都是功能互补的，没有所谓的万金油方案。 所以 svrx 带给我们其实并不是 svrx-plugin-mock、svrx-plugin-json-server亦或是svrx-plugin-nei 等等这些隔离的单一功能， 而是基于 svrx 这个平台，我们可以很容易的将这些围绕在dev-server领域的功能以一种统一的方式集成起来使用，避免重复的安装和配置工作。 举个栗子 &#x1F330;，当开发者希望 JSON 响应的格式输出更好看时，可以直接使用-p json-viewer来激活对应插件： svrx --route router.js \\ -p json-viewer \\ -p json-server \\ -p mock 响应视图立刻从下面的无序纯文本： 无缝切换为直观的下图： 再举个栗子 &#x1F330;，当我们想将我们的本地服务暴露到外网使用时，可以使用 -p localtunnel 激活 localtunnel 的反向隧道网关服务。 svrx --route route.js \\ -p json-viewer \\ -p json-server \\ -p mock \\ -p \"localtunnel?host=https://tunnel.svrx.io\" 参数过长时可以使用 svrx 配置文件中 tunnel.svrx.io 是属于福利性设施，不确保稳定性，请大家悠着点使用以避免服务因为各种原因不可用。 上图类似 https://fast-dragon-86.tunnel.svrx.io 的随机地址即可用于外网访问的域名了，这种即开即走的使用体验是碎片化的各种 dev server 平台无法提供给你的。 更重要的是，接口 mock 其实仅仅只是我们日常开发中的一环，svrx 的定位是一个通用开发服务器，它内置集成了serve、proxy、livereload、route等等日常前端开发中必不可少的功能， 并且可以通过社区不断增加的插件池来进行自由组合使用，这个我们从上述接口 mock 这一场景的描述中应该已经看到。 完全可以这么说，围绕 dev-server 的设施越多，svrx 存在的价值就越大 写在最后 除了完全不推荐的「硬编码方案」之外，做到与业务代码解耦的「纯前端拦截」和「纯后端拦截」的接口 mock 方案也都存在一些无法规避的本质性问题。 而使用 svrx 以及它配套的社区插件，我们除了可以整合前端和后端拦截的优势，还可以将各种 mock 功能集成在一个服务中运行，解决了工具的碎片化问题，从而高效的实现接口 mock 需求。 Links svrx（读音:Server-X） 是一个渐进且易于使用的、插件化的前端开发服务器。 Server-X：一款可能提升你十倍工作效率的工具 mock.js(前端 mock 工具库)以及对应的svrx-plugin-mock插件 json-server: Get a full fake REST API with zero coding in less than 30 seconds (seriously) localtunnel: 一个反向隧道服务，用来暴露本地服务到公网域名，这里也有团队整理的 docker 快捷部署方案 NEI 接口管理平台: 网易研发团队都在使用的接口管理平台 Koa: 一个轻量级的 Nodejs 框架 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "}}