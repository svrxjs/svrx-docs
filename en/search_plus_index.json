{"./":{"url":"./","title":"What is svrx","keywords":"","body":"svrx svrx(server-x) is a pluggable platform built for efficient front-end development. As a front-end developer, to meet different kind of development requirements, usually we will have one or more set of fixed development environment, in which may include a local dev server and many other debug tools. It's difficult to maintain a development environment: you need to install and configure every tool separately. Besides, you may also need to enable or disable a tool when switching among projects. To solve the problem, we plan to integrate all the development services and tools into a pluggable platform, and name it svrx. With svrx, you can freely pick and combine any services(plugins) you want, like static serve, proxy, remote debugging and etc, without concerning about plugin installation. Now, svrx makes it possible for us to easily customize the development environment for each project, and instead of downloading many other packages, all you need to do is just install svrx. Features static serve proxy page live reload routing with hot reloading and you can do more: plugin Install & Usage View quick start for more details. Official Plugins Debug svrx-plugin-weinre: remote debugging based on weinre. svrx-plugin-eruda: open a dev tool on mobile based on eruda Mock svrx-plugin-json-server: based on json-server, help us to get a full fake REST API with zero coding. svrx-plugin-mock: Provide us with a convenient way to mock data Build & Compile svrx-plugin-webpack: support of webpack, including building, hot-reload and etc. Serve svrx-plugin-markdown: preview markdown file, support hot-reload, auto-scroll... svrx-plugin-json-viewer: Convert the JSON response to a json viewer's page, but it won't affect the response via ajax or fetch. Network svrx-plugin-localtunnel: expose your localhost to the world for easy testing and sharing. Utility svrx-plugin-qrcode: display the qrcode of current page. More See plugin list for more plugins that available in community. Reading plugin development guide， It’s not difficult to publish your own plugin Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"quick-start.html":{"url":"quick-start.html","title":"Getting Started","keywords":"","body":"Getting Started Let's get started with svrx now! Install svrx We strongly recommend to use official cli tool to manage svrx. You can use svrx at any place in your system after installing @svrx/cli globally. npm install -g @svrx/cli HINT: @svrx/cli is used to install and load svrx with a specific version(default to the latest one), which has nothing to do with the version of @svrx/cli itself. You can specify the svrx version you want in command line or the .svrxrc.js file. @svrx/cli stored the versions of svrx into ~/.svrx, you can use another directory by setting the SVRX_DIR environment variable. Starting A Project With Svrx Common Commands There are several commands in @svrx/cli you might use frequently: svrx # start svrx service svrx serve # same as svrx ('serve' can be omitted) svrx --version # check the version of cli and svrx currently use svrx --help # print help info Usage Start svrx Before we start, you need to cd into the root of your project first. Let's say you've already got an index.html in your project: cd your_project ls # index.html And without any other config, just run serve command to start the dev server: svrx Then visit http://localhost:8000 to see the content of index.html. Command Line Options You can pass options to change the default behavior through command line: svrx --port 3000 --https --no-livereload Check out the full option reference doc here. .svrxrc.js And also, you can write down all your options by creating a file named .svrxrc.js or svrx.config.js in the root path of your project. // .svrxrc.js module.exports = { port: 3000, https: true, livereload: false }; And then run serve command, svrx will read your options from the config file automatically. Global Settings Sometimes, you might want some global settings on svrx. Let's say, all your projects need https protocol, it's really unnecessary to set https to true in every project. You can put the global config file to the directory in which we stored the svrx packages, the default path is, as mentioned before, ~/.svrx/config. // ~/.svrx/config/.svrxrc.js module.exports = { https: true, }; Yes, the structure of global config file is same as those in each project. And next time, wherever you start svrx, the https protocol will be enabled by default. Moreover, the global configs have the lowest priority, you can overwrite global configs in your project at any time. Other Commands If you want to know the installed versions of svrx, or want to install a specific version, you might need the following commands: svrx ls # list all installed versions of svrx svrx ls-remote # list all published versions of svrx svrx install # install a specific of svrx svrx remove # remove a specific of svrx svrx remove # remove local cache of a plugin You can use svrx -h to see more help info of a command Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"plugin/":{"url":"plugin/","title":"Plugins","keywords":"","body":"Plugins How To Use Plugins The List of Plugins How To Write A Plugin Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"plugin/usage.html":{"url":"plugin/usage.html","title":"How To Use Plugins","keywords":"","body":"How To Use Plugins Command Line You can use plugins through command line options, eg: svrx --plugin markdown -p qrcode # -p is alias of --plugin svrx --markdown --qrcode # set a pluginName to true to start a plugin quickly svrx --plugin \"qrcode?ui=false\" # use 'name?querystring' to add params to a plugin svrx --plugin \"webpack@0.0.3\" # use 'name@version' to specify the version of plugin .svrxrc.js config file And also, you can enable and config a plugin through plugins in .svrxrc.js file, eg: // .svrxrc.js module.exports = { plugins: [ 'markdown', { name: 'qrcode', options: { ui: false, }, }, { name: 'webpack', version: '0.0.3', }, ], }; Then run svrx in the root place of your project, we'll install plugin markdown, qrcode, webpack, and start them automatically. scope Svrx plugin also support npm-scope. You can specific a scoped plugin with @/. For example, if the package name of a plugin is svrx-plugin-foo, and the scope name is bar, then you can use it like so: svrx --@bar/foo svrx -p @bar/foo svrx -p \"@bar/foo@0.0.3\" Or: // .svrxrc.js module.exports = { plugins: [ '@bar/foo', { name: '@bar/foo', options: { bar: false, }, }, ], }; You can easily create a scoped plugin through our official tool svrx-create-plugin. Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"plugin/contribution.html":{"url":"plugin/contribution.html","title":"How To Write A Plugin","keywords":"","body":"How To Write A Plugin Use svrx-create-plugin to help you create plugins more easily First Plugin Let's create our first plugin —— svrx-plugin-hello-world File Structure └── svrx-plugin-hello-world ├── client.js ├── index.js └── package.json Only package.json and index.js are required package.json { \"name\" : \"svrx-plugin-hello-world\", \"engines\": { \"svrx\" : \"0.0.x\" } } Only two fields are required by package.json name: package name must be a string beginning with svrx-plugin, to help svrx find it in npm. engines.svrx: Define the runnable svrx version of this plugin，svrx will automatically load the latest matching plugin engines.svrx can be a valid semver，like 0.1.x or ~0.1 - index.js module.exports = { configSchema: { user: { type: 'string', default: 'svrx', description: 'username for hello world' } }, assets: { script: ['./client.js'] }, hooks: { async onCreate({ logger, config }) { logger.log(`Hello ${config.get('user')} from server`); } } }; Where configSchema Plugin param definition based on JSON Schema ，checkout JSON Schema for more detail. Here we just set a user field, it is a string assets: client resource setting，they will be automatically injected into the page style: css resource injection script: script resource injection All resources will be merged into a single file. hook.onCreate: a function invoke when plugin been creating, we can control it by injected service in this example, we only use two services logger: logger service config: config service Check out setion service to find out other services that available in hook.onCreate - client.js There is a global variable named svrx will be injected into all pages, it has some built-in services svrx is only accessible inside the plugin script, don't worry about global pollution const { config } = svrx; config.get('user').then(user => { console.log(`Hello ${user} from browser`); }); You will see Hello svrx from browser in console panel Unlike in server side, config in client is passed through websocket, so api is async, and return a promise svrx also provide other client services, please check out client api for help publish && running There'll be a failure when trying to publish it by npm publish. Because svrx-plugin-hello-world has been published by official team So we skip this step and try the plugin directly svrx -p hello-world Check the terminal and browser console log, we will find Hello svrx from browser, which means plugin has worked successfully. You can also run it in programmatical way const svrx = require('@svrx/svrx'); svrx({ plugins: ['hello-world'] }).start(); Further reading: How to test plugin? Server Side Service You can use service in two places hooks.onCreate module.exports = { hooks: { async onCreate({ middleware, injector, events, router, config, logger, io }) { // use service here } } }; plugin event svrx(config).on('plugin', async ({ logger, io }) => { // use service here }); We will explain these 7 services in turn middleware Middleware is used for adding koa-style middleware to implement backend logic injection - middleware.add(name, definition) Adding koa-style middleware Usage middleware.add('hello-world-middleware', { priority: 100, async onRoute(ctx, next) {} }); Param name [String]: A unique middleware name in debug mode, it can be used to track the middleware call process definition.priority [Number]: default is 10. Svrx will assemble the middleware according to the priority from high to low, that is, the request will be passed to the high priority plugin first. definition.onRoute [Function]: A koa-style middleware .If definition is a function, it will automatically become definition.onRoute - middleware.del(name) Delete a middleware with the specified name Usage middleware.del('hello-world-middleware'); Param name: middleware name injector injector is used for rewriting the response and inject client resources. - injector.add(type, resource) Add a resource for injection , only js and css has been supported. The rule as follow. The style will be merged into /svrx/svrx-client.css and injected before the closing head tag The script will be merged into /svrx/svrx-client.js and injected before the closing body tag Usage injector.add('script', { content: ` console.log('hello world') ` }); The content will be merged into bundle script Param type: Only support script and style resource.content [String]: resource content resource.filename [String]: the path of resource file, must be a absolute path Content has a higher priority than filename, so you can take one of them. - injector.replace(pattern, replacement) injector.replace will transform response body with some or all matches of a pattern replaced by a replacement. Usage injector.replace(/svrx/g, 'server-x'); The above example replace all svrx with server-x Param pattern [String|RegExp] replacement [String|Function] The usage of injector.replace is exactly the same as String.prototype.replace resource injection is based upon injector.replace events Built-in event listener, support async&sorted emitter, , which can call the listen function in turn, and can terminate the event delivery at any time. - events.on(type, fn) Usage events.on('hello', async payload => {}); events.on('hello', async (payload, ctrl) => { ctrl.stop(); // stop events emit, only works in sorted emit mode }); Param type [String]: event name fn(payload, ctrl): callback that has two params payload [String]: event data that pass through emit ctrl [Object]: control object, call ctrl.stop() to stop 'sorted emit' If the callback returns a Promise (such as async function), it will be treated as an asynchronous watcher. - events.emit(type, param, sorted) Usage // sorted emit, handler will be called one by one events.emit('hello', { param1: 'world' }, true).then(() => { console.log('emit is done'); }); // parallel emit events.emit('hello', { param1: 'world' }).then(() => { console.log('emit is done'); }); Param type [String]: event name payload: event data sorted [Boolean]: default is false, whether to pass events serially Return Promise - events.off(name, handler) Remove event watcher Usage events.off('hello'); // remove all hello's handler events.off('hello', handler); // remove specific handler builtin events plugin: triggered after plugin building. file:change: triggered when any file changes ready: triggered when server starts, if you need to handle logic after server startup (such as getting the server port), you can register this event config Config service used to modify or query the options passed by user; - config.get(path) Get the config of this plugin. Config is based on immutable data , you must always use config.get to ensure getting the latest config. Usage config.get('user'); // get the user param belong to this plugin config.get('user.name'); // get the user.name param belong to this plugin if you need to get global config，just add prefix $. config.get('$.port'); // get the server's port config.get('$.root'); // get the svrx working directory Param field: field path，deep getter must be separated by ., such as user.name Return The value of the field - config.set(field, value) Modify the config Usage config.set('a.b.c', 'hello'); // deep set config.get('a'); // => { b: { c: 'hello' } } Param field: field path，deep setter must be separated by ., such as user.name value: field value - config.watch(field, handler) Listening for configuration changes, change digest will be triggered after the set, del, splice method calls config.watch((evt)=>{ console.log(evt.affect('a.b.c')) => true console.log(evt.affect('a')) // => true console.log(evt.affect('a.c')) // => false }) config.watch('a.b', (evt)=>{ console.log('a.b has been changed') }) config.set('a.b.c', 'hello'); Param field: field path，deep watcher must be separated by ., such as user.name handler(evt): watch handler evt.affect(field) [Function]: detect whether specific field has been changed - config.del(field) Remove some field Usage config.del('a.b.c'); config.get('a.b.c'); //=> undefined - config.splice(field, start[, delCount[, items...]) The Array.prototype.slice Except for field，params are identical to Array.prototype.splice Example config.set('a.b.c', [1, 2, 3]); config.splice('a.b.c', 1, 1); config.get('a.b.c'); // => [1,3] router Extending Routing DSL - router.route(register) Register route，as same as Routing DSL Usage const {route} = router; route(({all, get, post})=>{ all('/blog').to.send('Hi, Blog') get('/user').to.send('Hi, user') post('/user').to.send({code: 200, data: 'Success!'}) }) Param register({...methods}): methods: corresponding to HTTP methods - router.action(name, builder) Register an action , like proxy or json Usage const { action, route } = router; action('hello', user => ctx => { ctx.body = `hello ${user}`; }); route(({ all }) => { all('/blog').hello('svrx'); //=> response 'hello svrx' }); Param name [String]: action name builder(payload) payload: payload that passed to action，like 'svrx' in above example Return: builder must return a koa style middleware - router.load(filename) Load routing file manually ，Same as options --route Also support hot reloading Usage await router.load('/path/to/route.md'); Param filename: absolute path for routing file Return Promise logger Logger module, who's level can be controlled by logger.level (default is warn) svrx({ logger: { level: 'error' } }); Or cli way svrx --logger.level error Above example will output log that more than warn, such as notify, error logger[level](msg) Svrx provides multiple levels of logging: silent, notify, error, warn (default), info, debug Usage logger.notify('notify'); // show `notify` logger.error('error'); // show `error` and `notify` logger.warn('warn'); // show `warn`、`error` and `notify` logger.log is an alias for logger.notify io io is used for the communication between server and client. Please check it out in client-side io - io.on( type, handler ) Listening for client messages (send by client side io.emit) io.on('hello', payload => { console.log(payload); // =>1 }); Param type: message type handler(payload): handler for message payload: message data - io.emit(type, payload) Send message to client Usage Server side io.emit('hello', 1); Client side const { io } = svrx; io.on('hello', payload => { console.log(payload); //=>1 }); Param type: message type payload: message data Message payload must be serializable because they are transmitted over the network - io.off(type[, handler]) Remove the message watcher Usage io.off('hello'); //=> remove all hello handlers io.off('hello', handler); //=> remove specific handler - io.register(name, handler) Register io service， which can be invoked by io.call in client and server. Usage io.register('hello.world', async payload => { return `Hello ${payload}`; }); Param name [String]: service name used by io.call handler: a Function return Promise, implement service logic - io.call(name, payload) Invoke registered service Usage io.call('hello.world', 'svrx').then(data => { console.log(data); // => Hello svrx }); Param name [String]: service name payload [Any]: service payload will passed to service handler Return Promise Client API The client APIs are uniformly exposed through global variable svrx const { io, events, config } = svrx; io Responsible for communicating with the server - io.on(type, handler) Listening server-side message Usage Server side io.emit('hello', 1); Client side const { io } = svrx; io.on('hello', payload => { console.log(payload); //=>1 }); Note that the io.emit() in server-side is a broadcast and all pages will receive a message for server. Param type: message type handler(payload): message handler payload: message payload passed by io.emit - io.emit(type, payload) Send client message to server side Usage Client side const { io } = svrx; io.emit('hello', 1); Server side { hooks: { async onCreate({io}){ io.on('hello', payload=>{ console.log(payload) // =>1 }) } } } Param type: message type payload: message data passed to message handler payload must be serializable because it is transmitted over the network. - io.off(type[, handler]) Remove io watcher Usage io.off('hello'); //=> remove all hello handlers io.off('hello', handler); //=> remove specific handler - io.call(name, payload) io.call on the client side is exactly the same as the server, but make sure the payload is serializable** because it will be transmitted over the network Usage io.call('hello.world', 'svrx').then(data => { console.log(data); }); Param name [String]: service name payload [Any]: service payload Return Promise events This part is exactly the same as server events, no retelling Usage const { events } = svrx; events.on('type', handler); events.emit('type', 1); events.off('type'); The difference between events and io is that io is used for the communication between the server and the client, but events is a single-ended communication. config config in client is almost identical to the server, the only difference is: the client version is asynchronous (because of network communication) - config.get(field) Usage config.get('$.port').then(port => { // get the server port }); config.get('user').then(user => { //get the param belongs to current plugin }); if you need to get global config，just add prefix $. - config.set、config.splice、config.del The above three methods are the same as get, which is consistent with the server, but the return value becomes Promise. Usage config.set('a.b', 1).then(() => { config.get('a.b').then(ab => { console.log(ab); // => 1 }); }); config schema Svrx config schema is based on JSON Schema Usage module.exports = { root: { type: 'string', default: process.cwd(), description: 'where to start svrx', ui: false }, route: { description: 'the path of routing config file', anyOf: [{ type: 'string' }, { type: 'array' }] }, logger: { description: 'global logger setting', type: 'object', properties: { level: { type: 'string', default: 'error', description: \"set log level, predefined values: 'silent','notify','error','warn', 'debug'\" } } } }; Field Details type [String]: JSON-Schema field type ，can be an array,string,number,boolean,object or null default [Any]: default value required [Boolean]: whether it is required, default is false properties [Object]: child fields ui: svrx extension ，whether show the config in svrx-ui anyOf: Choose one of the items, such asroute: { description: 'the path of routing config file', anyOf: [{ type: 'string' }, { type: 'array' }], }, For further understanding, please refer to Official Documentation How to test plugin? It is not recommended that you publish the test plugin to npm. You can do local testing in the following ways. svrx({ plugins: [ { name: 'hello-world', path: '/path/to/svrx-plugin-hello-world' } ] }).start(); After specifying the path parameter, svrx loads the local package instead of installing it from npm More easier plugin development Use Official svrx-create-plugin to help you create plugins more easily Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"practice/":{"url":"practice/","title":"Practice","keywords":"","body":"Practice Recipes Integrations Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"practice/recipe.html":{"url":"practice/recipe.html","title":"Recipes","keywords":"","body":"Recipes We can easily add plugins to most projects to simplify our development flow. Here are some examples of how to use svrx and some common plugins, hope it helps. serve a static page proxy webpack use eruda dev tool on mobile weinre and remote debug Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"practice/integration.html":{"url":"practice/integration.html","title":"Integrations","keywords":"","body":"Integrations Initialize a project with create-react-app or vue-cli: # CRA npm init react-app my-app # Vue CLI npm i @vue/cli -g vue create my-app Create a file named webpack.config.js in root directory: // CRA module.exports = require('react-scripts/config/webpack.config')('development'); // Vue CLI module.exports = require('@vue/cli-service/webpack.config'); And it works like a charm &#x1F389; svrx --webpack You can also combine with others plugins to get powerful dev experience. Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/":{"url":"guide/","title":"Guide","keywords":"","body":"Guide How To Use Routes API Reference Option Reference Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/route.html":{"url":"guide/route.html","title":"How To Use Routes","keywords":"","body":"How To Use Routes Getting Started You can try the following commands to start svrx routing quickly: touch route.js # create empty routing file svrx --route route.js In your route.js: get('/blog').to.json({ title: 'svrx' }); Then open /blog, you'll see the json output {title: 'svrx'}. Features support hot reloading ( check it out by editing your route.js now) easy writing, clear reading support expanding through plugin Syntax [method](selector).to.[action](payload) For example: post('/blog').to.proxy('http://music.163.com'); This rule can be translate into: method: post selector: /blog action: proxy payload: 'http://music.163.com' 'to' is just a preposition word here, which can be omitted Route Route Methods svrx route supports all the http methods defined by methods. ⚠️ 'delete' is a reserved word of javascript, so you might use del() to create a DELETE method. Route Matching The match rule of svrx route is based on path-to-regexp, which is also used by express and koa. The following is just some briefs of matching rules, please check path-to-regexp doc for more detail. Common Rules /svrx/:id: named parameters matching, default parameter rule is (\\w+) /svrx/:id(hello|world): named parameters matching with custom parameter matching rule /svrx(.*): unnamed parameters matching /\\/svrx\\/(.*)$/: use regexp directly for complicated routes Parameters named parameters like /:id, can be accessed through ctx.params.id unnamed parameters like /(hello|world)/(.*).html, can be accessed through ctx.params[0] and ctx.params[1] regexp like /\\/svrx\\/(.*)$/, can be accessed through ctx.params[i] in order Parameters Mapping In fact, except Action:handle, most actions do not have the ability to access the koa context, so we need parameters mapping for some actions. Take sendFile as an example: get('/html/:path.(html|htm)').to.sendFile('./{path}.{0}') /html/index.html will send ${root}/html/index.html /html/home.htm will send ${root}/html/home.htm Action List You can use Route API for Plugins to write your own action. send Send response content. get('/blog').to.send({ title: 'this is a blog' }); send is a syntactic sugar for ctx.body of koa. And there're some default behaviors for different payload types. string if started with , like , the Content-Type header will be set as text/html if not, return text/plain object or array or number or boolean ... return json, the Content-Type will be application/json sendFile Send file content, and it will auto set the Content-Type header according to the file extension. get('/index.html').to.sendFile('./index.html'); root path = serve.base || root ⚠️support parameters mapping, for example: get('/file/:id.html').to.sendFile('./assets/{id}.html') json Send json response, despite the type of payload. get('/blog').to.json({title: 'svrx'}); redirect(target[, code]) Server side redirecting. target: target path code: http code, default is 302 get('/blog').to.redirect('/user'); ⚠️support parameters mapping, for example: get('/blog/:path(.*)').to.redirect('/user/{path}') header Set response headers. header doesn't send any response content, so you can chain this action to other actions. get('/blog') .to.header({ 'X-Engine': 'svrx' }) .json({ code: 200 }); rewrite Rewrite routes. ⚠️support parameters mapping get('/old/rewrite:path(.*)').to.rewrite('/svrx/{path}') get('/svrx(.*)').to.send('Hello svrx') Both /old/1 and /svrx/1 will return Hello svrx. rewrite doesn't send any response content, you can chain this action to other actions. proxy(target[, options]) Proxy path to target server. target: target server options: same as proxy.options changeOrigin secure pathRewrite get('/api(.*)').to.proxy('http://mock.server.com/') get('/test(.*)').to.proxy('http://mock.server.com/', { secure: false, }) get('/test/:id').to.proxy('http://{id}.dynamic.server.com/') handle handle is a powerful action, it defines a middleware of koa, which means all actions above can be implemented by handle, but the cost is the reduction of code readability. get('/hello-world').to.handle((ctx)=>{ ctx.type = 'html' ctx.body = 'Hello World' }); Instead of using handle, it is recommended to use 'smaller' actions, you can customize your own actions using route api for plugins, see next section. Route API for Plugins You can create a new action in your own plugin. There's a router object in your hooks.onCreate, which has 3 methods inside: action: register an action just like proxy, json, ... load: load a routing file route: define a router in scripts Please read How To Write A Plugin for more information. Examples get('/handle(.*)').to.handle((ctx) => { ctx.body = 'handle'; }); get('/blog(.*)').to.json({ code: 200 }); get('/code(.*)').to.send('code', 201); get('/json(.*)').to.send({ json: true }); get('/text(.*)').to.send('haha'); get('/html(.*)').to.send('haha'); get('/rewrite:path(.*)').to.rewrite('/query{path}'); get('/redirect:path(.*)').to.redirect('localhost:9002/proxy{path}'); get('/api(.*)').to.proxy('http://mock.server.com/') get('/test(.*)').to.proxy('http://mock.server.com/', { secure: false, }) get('/test/:id').to.proxy('http://{id}.dynamic.server.com/') get('/query(.*)').to.handle((ctx) => { ctx.body = ctx.query; }); get('/header(.*)') .to.header({ 'X-From': 'svrx' }) .json({ user: 'svrx' }); get('/user').to.json({ user: 'svrx' }); get('/sendFile/:path(.*)').to.sendFile('./{path}'); Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/api.html":{"url":"guide/api.html","title":"API Reference","keywords":"","body":"API Reference svrx(option) Get the instance of Svrx Usage const svrx = require('@svrx/svrx'); const server = svrx({ port: 8002 }); Param option: see option reference Return the instance of Svrx server.start() Start svrx Usage server.start().then(port => { console.log(port); }); Return Promise server.close() Usage server.close().then(() => { console.log('Svrx has closed'); }); Param Return Promise server.reload() Manually refresh the browser Usage server.reload(); server.on Attach event listener builtin events 1. ready Emit when svrx start server.on('ready', port => {}); 2. plugin Emit after plugin building, as same as hook.onCreate, see How to create plugin for more details server.on('plugin', async ({io, events, config, router, injector, logger, middleware }=>{ // you logic here })) 3. file:change emit after file change (make sure that livereload is enable) server.off unbind specific event server.on('file:change', handler); server.off('file:change', handler); server.emit server.emit('custom-event', { param1: 1 }); Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"guide/option.html":{"url":"guide/option.html","title":"Option Reference","keywords":"","body":"Option Reference root string Where to start svrx. Default to the current working directory. svrx string The version of svrx you want to use. Default to the latest version installed locally, if not installed, it will the use the latest published version. port number Specify a port number to listen for requests on, default to 8000. https boolean Enable/Disable https service. Default to false. route string Specify the configuration file of routing, see routing dsl guide for more detail. svrx --route route.js It supports hot-reload, which means that you can update your routing rules without restarting svrx manually. livereload boolean, object Enable/Disable auto page live reload. Livereload is enabled by default. livereload.exclude string, string[] Specify patterns to exclude from file watchlist. If a file matches any of the excluded patterns, the file change won’t trigger page reload. serve boolean, object The set of dev server options. serve.base string Tell the server where to serve static content from. By default, we'll looking for contents at the current working path. This option is necessary only when you want to serve static files. serve.index string Name of the index file to serve automatically when visiting the root location, default to index.html. serve.directory boolean Enable/disable serveIndex middleware. directory is enabled by default. When visiting the root location, if there's no index file exists, serveIndex middleware displays a view of filelist in the directory instead of a 404 page. open boolean, string Enable auto opening browser after svrx started. By default, it will open http://localhost:${port} automatically. You can also specific the opening page by setting open to: true: same as 'local' 'local': open local url, http://localhost:${port} 'external': open external url, http://${your_ip}:${port}/ 'home.html': same as 'local/home.html', open http://localhost:${port}/home.html Set open to false to disable auto open browser. historyApiFallback boolean, object Enable/disable historyApiFallback middleware. It is set to false by default. This option is necessary when your app is using HTML5 History API, historyApiFallback middleware will serve a index.html page instead of 404 responses. proxy proxy is also supported in route configuration file boolean, object, object[] Proxying urls when you want to send some requests to different backend servers on the same domain. module.exports = { proxy: { '/api': { target: 'http://you.backend.server.com' } }, } Now a request to /api/path will be proxied to http://you.backend.server.com/api/path. And you can also rewrite the path, eg: module.exports = { proxy: { '/api': { target: 'http://you.backend.server.com', pathRewrite: {'^/api' : ''} } }, } Then your request to /api/path will be proxied to http://you.backend.server.com/path. A backend server running on HTTPS with an invalid certificate will not be accepted by default. If you want to, modify your config like this: module.exports = { proxy: { '/api': { target: 'https://you.https.server.com', secure: false } }, } If you want to proxy multiple paths to a same target, try: module.exports = { proxy: [ { context: ['/api', '/wapi', '/pub'], target: 'http://you.backend.server.com', } ], } Please note that by default, the option value of changeOrigin is true, which means svrx will always set the origin of host header to the target hostname during CORS. If you don't want this feature, just set changeOrigin to false: module.exports = { proxy: { '/api': { target: 'https://you.https.server.com', changeOrigin: false } }, } cors boolean, object Enable/disable cross-origin resource sharing(CORS). Cors is enabled by default. svrx makes use of koa2-cors package. Check out its option documentation for more advanced usages. registry string Specific the npm registry where svrx should download plugins from. By default, svrx will use the registry set at your workspace, you can check with command: npm config get registry path string The local path of the svrx core package. ONLY in development mode, to load a local svrx core package. Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"contribution.html":{"url":"contribution.html","title":"Contributing","keywords":"","body":"Contributing to svrx Show me your code! All contributions are welcomed at svrx repo and other svrx packages. And feel free to tell us your ideas and suggestion about svrx on our issue page. Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"blog/":{"url":"blog/","title":"Blog","keywords":"","body":"Blog This the blog of svrx team, we will occasionally post articles about feature introduction, usage tips and code design here. Contributions in any kind are extremely welcomed! Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "},"blog/introduction.html":{"url":"blog/introduction.html","title":"Server-X：An Introduction","keywords":"","body":"Server-X: A Pluggable Platform For Local Frontend Development This page will introduce a brand-new frontend devtool, hope it can save you from switching among dev tools, while still bring you the same experience. I know what you are thinking, we're not newbies, as bald experienced frontend programmers, we all have several sets of development environment on our computers. So why should we change to another devtool? Look, you are almost there! So let's do a count game together. For the better frontend development experience, what exactly is the number of tools and apps you have installed on your computer? I guess there're local server, remote debug tool, proxy tool, broswer plugins and etc. It must cost you a long period of time, and must be a hard choice to finallly decide to compose them as a stable development envelopment. Besides, most of those tools require a global installation, which means, if you got a new computer, you have to install all of those tools back. And your devtools cannot configure projects separately, usually, you have to change your devtool's configuration after switching projects. Let's sum up those trouble scenes we're used to during project development: You have to install kinds of tools and apps for local development envelopment The local development envelopment is hard to copy or share between computers You need to configure tools one by one, and most of them are not isolated among projects Sometimes you find NO tools to meet your requests, and it's troublesome to write your own tools During developing, you have to start many tools at same time: dev server, mock server and so on And you often need to restart those tools to refesh configuration ... ... Based on the pain points above, here comes server-x. What is server-x Like the first half of the name, server, you can say, server-x(short as 'svrx') is just a local server, and it's a powerful, handy and light-weighted server. Before everything, let's have a look at the simplest use case: Firstly you need to install the CLI tool of svrx, npm install -g @svrx/cli And create a simple page, then start svrx at the root path, mkdir example && cd example echo 'Hello svrx!' > index.html svrx Visit http://localhost:8000, you can see your page. It's convenient to install, quick to start, and except NodeJS, it doesn't depend on any environment. Of course, that's the key feature of any independent and basic dev servers. So can svrx do more? The answer is yes. Svrx also has some practical built-in features like broswer auto openning, page livereloading, proxy and so on. Ok, you might say, some dev servers can do this too. Actually, the biggest difference between svrx and other local servers is, as the other half of its name server-x: x. According to the Internet, x can represent \"unknown and infinity\", you can say svrx is a server with infinite possibilities. Why? Because there's a most outstanding feature in svrx: it's a platform of plugins. Through plugins, your svrx can have any function in theory. Every small function here is an independent plugin, you just need to declare them before use, like this: svrx --webpack --qrcode --markdown It's very clear, and with no redundant configuration. After your declaration, svrx will help you install and load plugins, then start the service directly. As you see, svrx is a platform that aggregates plenty of plugins. It can be a whole development environment itself. The only difference is, you don't need to care about the plugin installation at all. Except the CLI of svrx, you don't need to install any other tools. And what's more, none of plugins is installed globally. Svrx installs plugins into the node_modules directory of your project', so everything is truly independent, you can customize the development environment for each project without concerning about the installation or uninstallation, there's no contamination, and your system can keep clean at the same time. Actually, there're many local dev servers published. But nearly none of them is like svrx, which is light-weighted, easy to use, with complete plugin system and not rely on any project environment. Next, let's keep exploring the development experience of svrx through creating a simple frontend project. You'll see some advanced usages and black-techs, that's the most charming part of svrx. Init A New Project And Start Now, we will use Create React App to create a new project. (As mentioned before, svrx does not rely on any project environment, it's only for the convenience we choose CRA) npm init react-app svrx-example cd svrx-example By default the new project uses webpack to bundle code, to start projects like this, we need a plugin named svrx-plugin-webpack. The purpose of this plugin is to make your webpack project work in svrx. Basically it will read project webpack config, and then call webpack-dev-middleware. But our new project here is not exposed the config of webpack, so firstly we need a webpack.config.js at the root: // webpack.config.js module.exports = require('react-scripts/config/webpack.config')('development'); And now we can start our project successfully: svrx --webpack Your broswer will auto open http://localhost:8000/ for you: Try edit src/App.css, check if the page auto reloaded? Advanced Usage 1: Configure Your Svrx By default, svrx will enable some built-in plugins when start, such as static serve, proxy service, page livereloading and etc. All of those plugins have some default configuration which ensure that svrx can be quickly started. Of cource, if you want to make some custom decision, there're two ways. Firstly, you can pass some params to CLI when starting svrx: svrx --port 3000 --https --no-livereload And also, you can create a .svrxrc.js or a svrx.config.js at the root path of your project, then run svrx to start your project directly: // .svrxrc.js module.exports = { port: 3000, https: true, livereload: false }; All of the options and details can be found at svrx docs - options. Advanced Usage 2: Try Other Plugins Besides built-in plugins, there're also many other independent plugins, like svrx-plugin-webpack mentioned before.When you need other development function(such as remote debug, mock and so on), all you have to do is just declare the plugin name. In fact, it is the independent plugins that provides feature-rich experience. Next, we will introduce several useful and interesting plugins: localtunnel - Expose Your Local Service Image that you're working on your page developing intently, suddenly there's a message toast from your boss: Let me see how's the page going on? What do you gonna do? I guess you might commit your code first, deploy a local service, and give your IP address of LAN to your boss. Hold on, what if your boss is on a business trip right now, he doesn't have access to your LAN! Ok, there's still a plan. You find a server and deploy a test environment for your boss, though the deploy might be slow and your boss has to wait for a long while. Any other solution? Yes, you need localtunnel plugin of svrx! It exposes your local service to localtunnel.me, so that you can test and share your local code with others easily. You don't need to deploy your test environment over and over again just for a little code change. To start localtunnel, just add the plugin name at the end: svrx --webpack --localtunnel This command will auto install plugin localtunnel and start svrx, other people(yes, you don't have to be in a same LAN) now can visit the url https://*.localtunnel.me printed by terminal to see your local service: Besides, every local changes made by you can be seen by others, don't worry about the boss anymore. weinre - Debug Your Code Remotely How do you debug your code on the phone? Many developers will choose chrome remote debugging. But to use it, you need to connect your computer and your mobile phone with a USB first. Is there a better way? Try plugin weinre of svrx. It is used to debug your code remotely, and it's wireless. Let's be back to our example peoject, this time we add two new plugins: svrx --open=external --webpack --weinre --qrcode Now we start svrx with weinre and qrcode, and use your phone to visit the project page, plugin qrcode here is just to make it easier for your phone to visit the page: Then open the debug page of weinre using your computer, the default url is http://${your_ip}:8001, find the record of your phone, and you can debug your page on the phone now. Customize Your Plugin Besides those we mentioned, there're many other useful plugins in svrx, you can search plugin at the official site of svrx, and then compose different plugins to get your own development environment. Of course, if you don't find a proper plugin, you can try to write one yourself. What can you do with the plugin? Take the plugin qrcode as an example, to print a qrcode on the page, you can inject some js and css scripts to the frontend page. And like the plugin webpack, you can inject some koa style middlewares to the backend service, here is the webpack-dev-middleware, intercept requests and modify the responses. With the greate power of scripts and middlewares injection, you can do nearly any thing during local development by creating svrx plugins. And it's extremely easy to create a new plugin! Can you believe it? The code size of plugins we mentioned is only 50 lines in average! Moreover, svrx also provides a command line scaffolding tool for quick plugin development, see How To Write A Plugin for more detail. Advanced Usage 3: Route With Hot Reloading Usually, as a frontend developer, you need to mock api response datas at the very beginning of the project. So you must have run into situations like: change mock data, restart the mock server enable / disable api proxy, restart the service edit project source code, restart ... ... Ok, even if the mock services are good enough that they don't need to restart now, you still need to start a mock server along side your local dev server, or, you put your mock data into your source code, that's really NOT a good idea! So, here comes our dynamic route. Besides the powerful plugin system, there's another useful and magic feature in svrx: the dynamic route. Let's get back to our example project, you can have a try on dynamic route like: touch route.js # create empty routing file svrx --webpack --route route.js In route.js: get('/blog').to.json({ title: 'svrx' }); Now open /blog, you'll see the output { title: 'svrx' }. With dynamic route, you can quickly and clearly create your mock data without intruding into your source code. And it supports hot reload, everytime after editing route.js, you don't need to restart svrx, the data will update automatically. Of course, the dynamic route can do more than data mocking. There're some examples of dynamic route: get('/index.html').to.sendFile('./index.html'); get('/blog').to.redirect('/user'); get('/old/rewrite:path(.*)').to.rewrite('/svrx/{path}'); get('/api(.*)').to.proxy('http://mock.server.com/'); get('/blog') .to.header({ 'X-Engine': 'svrx' }) .json({ code: 200 }); As you can see, the syntax of route is very simple, you can directly read every actions and clearly know what they gonna do: send files, refirect, rewrite, proxy and etc. Moreover, if the built-in route actions cannot fit your need, you can expand the route action through plugin by yourself. Read How To Use Routes for more detail. In The Last A pluggable frontend server, it just works. This is the slogan of svrx, which is sufficient to reveal the location of svrx: svrx is a useful local dev server, which contains some built-in plugins like static serve, proxy, livereload and etc svrx has a powerful plugin system, you can customize your dev environment through plugins Svrx is trying to bring an elegant development experience to all frontend developers, at the same time, we also offer you a platform to quickly create your own feature plugin. As a svrx user, you can pick suitable plugins to compose a better development environment, which can be quickly started without any installation. If there's no plugin meet your need, you can also turn to a plugin developer and write your own plugin. Surely your ideas can solve many other developer's problems and improve their development experience. Later, svrx will keep working on more features and plugins of high quality, and your contributions are also welcomed! Links svrx - the official site docs, API, plugin list svrx - Github source code, issue, pr Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2020-04-13 16:41:25 "}}